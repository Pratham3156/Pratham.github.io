<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>ChillBox</title>
  <link rel="icon" type="image/png" href="logo.png">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    /* DARK-ONLY ChillBox (desktop-first) */
    :root {
      --bg-1: #050505;
      --bg-2: #0b0b0b;
      --card: #121212;
      --accent: #1db954;
      --muted: #9aa0a6;
      --glass: rgba(255, 255, 255, 0.03);
      --glass-2: rgba(255, 255, 255, 0.02);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      height: 100%;
      overflow-x: hidden;
    }

    body {
      margin: 0;
      font-family: Inter, "Segoe UI", Roboto, Arial, sans-serif;
      background: linear-gradient(180deg, var(--bg-1), var(--bg-2));
      color: #e6eef3;
      min-height: 100vh;
      position: relative;
    }

    header {
      position: fixed;
      left: 0;
      right: 0;
      top: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 14px 6%;
      z-index: 99;
      background: rgba(5, 5, 5, 0.95);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
    }

    .logo {
      font-weight: 800;
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      gap: 10px;
      color: inherit;
      text-decoration: none
    }

    .logo i {
      color: var(--accent)
    }

    nav a {
      color: inherit;
      text-decoration: none;
      padding: 8px 10px;
      border-radius: 8px
    }

    nav a:hover {
      background: var(--accent);
      color: #000
    }

    .header-right {
      display: flex;
      gap: 8px;
      align-items: center
    }

    .search-box {
      display: flex;
      gap: 8px
    }

    .search-box input {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.04);
      background: transparent;
      color: inherit;
      width: 260px
    }

    .btn {
      padding: 8px 10px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 700;
      background: rgba(255, 255, 255, 0.03);
      color: inherit
    }

    .btn.accent {
      background: var(--accent);
      color: #000
    }

    .wrap {
      max-width: 1200px;
      margin: 120px auto 30px;
      padding: 0 20px;
      position: relative;
      z-index: 2
    }

    .hero-wrap {
      position: relative;
      overflow: hidden;
      border-radius: 12px;
      margin-bottom: 14px;
    }

    .hero-bg {
      position: absolute;
      inset: 0;
      z-index: 0;
      filter: blur(8px) saturate(110%);
      background-size: cover;
      background-position: center;
      transition: background-image .6s ease-out;
      opacity: 0.14;
    }

    .hero {
      position: relative;
      z-index: 1;
      display: flex;
      gap: 20px;
      align-items: center;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.02), rgba(255, 255, 255, 0.01));
      padding: 14px;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }

    .hero img {
      width: 160px;
      height: 160px;
      border-radius: 10px;
      object-fit: cover;
      border: 2px solid rgba(255, 255, 255, 0.03)
    }

    .hero .meta {
      flex: 1
    }

    .hero h2 {
      margin: 0 0 6px
    }

    .hero .meta-muted {
      color: var(--muted)
    }

    .hero .controls {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center
    }

    .tabs {
      display: flex;
      gap: 8px;
      margin-top: 12px
    }

    .tab {
      padding: 8px 12px;
      border-radius: 8px;
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.04);
      cursor: pointer;
      color: #cfe8d8
    }

    .tab.active {
      background: var(--accent);
      color: #000;
      font-weight: 800
    }

    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 14px;
      margin-top: 12px
    }

    .card {
      background: var(--card);
      padding: 10px;
      border-radius: 10px;
      text-align: center;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
      transition: transform .16s ease-out, box-shadow .16s ease-out;
      will-change: transform;
    }

    .card:hover {
      transform: translateY(-6px);
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.6)
    }

    .card img {
      width: 100%;
      border-radius: 8px;
      display: block;
      margin-bottom: 8px;
      height: 160px;
      object-fit: cover
    }

    .card h4 {
      margin: 6px 0 3px;
      font-size: 0.98rem;
      color: #fff
    }

    .meta-muted {
      color: var(--muted);
      font-size: 0.9rem;
      margin-bottom: 8px
    }

    .card .row {
      display: flex;
      gap: 6px;
      justify-content: center;
      flex-wrap: wrap
    }

    .badge {
      display: inline-block;
      padding: 6px 8px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.04);
      font-size: 12px
    }

    .section {
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.005));
      padding: 12px;
      border-radius: 10px
    }

    .playlist-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 12px;
      margin-top: 10px
    }

    .playlist-card {
      cursor: grab;
    }

    .playlist-card.dragging {
      opacity: 0.5;
    }

    /* ---------------- MINI PLAYER (UPGRADED LAYOUT) — UPDATED TO USE GREEN BAR ---------------- */
    .mini-wrap {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 9999;
      display: none;
      /* show when playback starts */
      justify-content: center;
      pointer-events: auto;
    }

    .mini {
      width: 100%;
      max-width: 1400px;
      background: linear-gradient(180deg, #0b0b0b, #0e0e0e);
      border-top: 1px solid rgba(255, 255, 255, 0.02);
      padding: 10px 22px;
      box-sizing: border-box;
      display: flex;
      align-items: center;
      gap: 18px;
      box-shadow: 0 -6px 30px rgba(0, 0, 0, 0.6);
    }

    .mini-left {
      min-width: 220px;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .mini-left .t {
      font-weight: 800;
      font-size: 16px
    }

    .mini-left .a {
      color: var(--muted);
      font-size: 13px
    }

    .mini-center {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }

    .mini-controls {
      display: flex;
      gap: 14px;
      align-items: center;
      justify-content: center;
    }

    .mini-btn {
      width: 44px;
      height: 44px;
      border-radius: 8px;
      background: #141414;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.6);
    }

    .mini-btn.big {
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--accent);
      color: #000;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.7);
    }

    .mini-timeline {
      width: 100%;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    /* hide old input styles if any still present */
    .mini-timeline input[type=range] {
      display: none;
    }

    .mini-time {
      color: var(--muted);
      font-size: 13px;
      width: 48px;
      text-align: center;
    }

    .mini-right {
      display: flex;
      align-items: center;
      gap: 12px;
      min-width: 220px;
      justify-content: flex-end;
    }

    .mini-right input[type=range] {
      width: 100px;
    }

    /* overlay and other styles remain unchanged */
    .player {
      position: fixed;
      left: 0;
      right: 0;
      bottom: 0;
      height: 0;
      background: transparent;
      display: none;
    }

    .overlay {
      position: fixed;
      inset: 0;
      z-index: 10000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.84), rgba(0, 0, 0, 0.94));
      backdrop-filter: blur(2px);
      -webkit-backdrop-filter: blur(2px);
    }

    .player-panel {
      width: 980px;
      max-width: calc(100% - 60px);
      border-radius: 12px;
      overflow: hidden;
      display: flex;
      gap: 14px;
      background: linear-gradient(180deg, rgba(20, 20, 20, 0.9), rgba(10, 10, 10, 0.9));
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
    }

    .left-col {
      width: 380px;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      align-items: center;
      text-align: center
    }

    .left-col img {
      width: 320px;
      height: 320px;
      border-radius: 12px;
      object-fit: cover
    }

    .right-col {
      flex: 1;
      padding: 18px;
      display: flex;
      flex-direction: column
    }

    .queue-list {
      overflow: auto;
      max-height: 460px;
      padding-right: 8px
    }

    .queue-item {
      display: flex;
      gap: 10px;
      align-items: center;
      padding: 8px;
      border-radius: 8px;
      cursor: pointer
    }

    .queue-item:hover {
      background: rgba(255, 255, 255, 0.02)
    }

    .queue-item.active {
      background: linear-gradient(90deg, rgba(29, 185, 84, 0.12), rgba(29, 185, 84, 0.06));
      border-left: 3px solid var(--accent);
      padding-left: 6px
    }

    .queue-item img {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      object-fit: cover
    }

    .queue-meta {
      flex: 1;
      font-size: 0.94rem
    }

    .queue-meta .t {
      font-weight: 700
    }

    .queue-meta .a {
      color: var(--muted);
      font-size: 0.9rem
    }

    .loader-wrap {
      display: flex;
      align-items: center;
      gap: 12px
    }

    .loader {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(255, 255, 255, 0.01));
      animation: spin 1.1s linear infinite;
    }

    .loader i {
      font-size: 16px;
      color: var(--accent)
    }

    @keyframes spin {
      from {
        transform: rotate(0)
      }

      to {
        transform: rotate(360deg)
      }
    }

    .main-layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 16px;
      margin-top: 18px;
      align-items: start;
    }

    img {
      image-rendering: -webkit-optimize-contrast;
      image-rendering: crisp-edges;
      image-rendering: pixelated;
    }

    .scroll-container {
      -webkit-overflow-scrolling: touch;
      overflow-anchor: auto;
    }

    @media (max-width:1024px) {
      .player-panel {
        flex-direction: column;
        width: 760px
      }

      .left-col img {
        width: 100%;
        height: auto;
        aspect-ratio: 1/1
      }

      .left-col {
        width: 100%
      }
    }

    @media (max-width:980px) {
      .main-layout {
        grid-template-columns: 1fr;
      }

      .mini {
        padding: 10px 12px;
      }

      .mini-left {
        display: none
      }

      /* reduce complexity on small screens */
    }

    @media (max-width:720px) {
      .hero {
        flex-direction: column;
        align-items: flex-start
      }

      .hero img {
        width: 120px;
        height: 120px
      }

      .grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr))
      }

      .player {
        height: 100px;
        padding: 8px
      }

      .player-left img {
        width: 56px;
        height: 56px
      }

      .left-col img {
        width: 100%;
        height: auto
      }

      .player-panel {
        max-width: 100%
      }

      .header-right {
        flex-direction: column;
        gap: 8px
      }

      .search-box {
        width: 100%
      }

      .search-box input {
        width: 100%
      }

      header,
      .hero,
      .overlay {
        backdrop-filter: blur(1px);
        -webkit-backdrop-filter: blur(1px);
      }

      .hero-bg {
        filter: blur(4px) saturate(110%);
      }

      body {
        -webkit-overflow-scrolling: touch;
      }
    }

    .footer {
      background: #0b0b0b;
      padding: 50px 6%;
      color: #ccc;
      margin-top: 60px;
    }

    .footer-content {
      display: flex;
      justify-content: space-between;
      flex-wrap: wrap;
    }

    .footer i {
      color: limegreen;
    }

    .footer-logo {
      font-size: 45px;
      font-weight: 700;
      color: white;
      margin-bottom: 10px;
    }

    .footer-brand p {
      line-height: 1.6;
      margin-bottom: 15px;
    }

    .footer-social a {
      margin-right: 12px;
      color: white;
      font-size: 18px;
      transition: 0.3s;
    }

    .footer-social a:hover {
      color: var(--accent);
    }

    .footer-section {
      min-width: 150px;
      margin-top: 20px;
    }

    .footer-section h3 {
      color: white;
      margin-bottom: 12px;
      font-size: 18px;
    }

    .footer-section a {
      display: block;
      color: #ccc;
      text-decoration: none;
      margin-bottom: 8px;
      transition: 0.3s;
    }

    .footer-section a:hover {
      color: var(--accent);
    }

    .footer-copy {
      text-align: center;
      margin-top: 30px;
      margin-bottom: 0;
      color: #777;
      font-size: 14px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      padding-top: 20px;
    }


    /* Search recommendation dropdown styles */
    #searchRecommendations {
      position: absolute;
      top: 42px;
      left: 0;
      width: 100%;
      max-width: 380px;
      background: #0f0f0f;
      border: 1px solid #222;
      border-radius: 8px;
      max-height: 300px;
      overflow-y: auto;
      display: none;
      z-index: 6000;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.6);
    }

    .search-rec-item {
      padding: 10px 12px;
      font-size: 14px;
      color: #e6eef3;
      cursor: pointer;
      border-bottom: 1px solid rgba(255, 255, 255, 0.02);
      display: flex;
      gap: 10px;
      align-items: center;
    }

    .search-rec-item small {
      color: #9aa0a6;
      display: block;
      font-size: 12px;
    }

    .search-rec-item:hover,
    .search-rec-item.active {
      background: rgba(29, 185, 84, 0.06);
    }

    .search-rec-thumb {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      object-fit: cover;
      flex: 0 0 40px;
    }

    .rec-empty {
      padding: 12px;
      color: #9aa0a6;
      font-size: 13px;
      text-align: center;
    }
.profile-container {
  position: relative;
  display: inline-block;
  cursor: pointer;
}

#profileImg {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  object-fit: cover;
  border: 2px solid #00ffd5;
}

.profile-menu {
  position: absolute;
  top: 55px;
  right: 0;
  background: #222;
  border-radius: 6px;
  display: none;
  min-width: 120px;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
}

.profile-menu a,
.profile-menu button {
  display: block;
  width: 100%;
  padding: 10px;
  background: none;
  border: none;
  color: white;
  text-align: left;
  cursor: pointer;
}

.profile-menu a:hover,
.profile-menu button:hover {
  background: #333;
}

  </style>
</head>

<body>
  <header>
    <a class="logo" href="#"><i class="fa fa-infinity"></i> ChillBox</a>
    <nav class="navbar" aria-label="main">
      <a href="index.html"><b>Movies</b></a>
      <a href="Music.Html"
        style="background:var(--accent);color:#000;padding:8px 10px;border-radius:8px"><b>Music</b></a>
      <a href="Games.html"><b>Games</b></a>
      <a href="AboutUs.html"><b>About US</b></a>
    </nav>
    <div class="header-right">
      <div style="position:relative;width:100%;max-width:380px">
        <div class="search-box" style="margin:0">
          <input id="searchInput" placeholder="Search artist or track..." autocomplete="off" aria-autocomplete="list"
            aria-controls="searchRecommendations">
          <button id="searchBtn" class="btn accent">Search</button>
        </div>
        <div id="searchRecommendations" role="listbox" aria-label="Search recommendations"></div>
      </div>
    </div>
<div class="profile-container">
  <img id="profileImg" src="default-avatar.png" alt="Profile">
  <div class="profile-menu" id="profileMenu">
    <button onclick="logout()">Logout</button>
  </div>
</div>
  </header>

  <div class="wrap scroll-container">

    <div class="hero-wrap">
      <div id="heroBg" class="hero-bg" aria-hidden="true"></div>

      <div class="hero" id="hero">
        <img id="heroArt" src="https://picsum.photos/300" alt="hero art">
        <div class="meta">
          <h2 id="heroTitle">Mood Mix</h2>
          <div id="heroArtist" class="meta-muted">Chill / Lo-fi picks</div>
          <p id="heroDesc" class="meta-muted" style="max-width:780px">Auto-rotating recommended tracks — click any Play
            to open full player and autoplay.</p>
          <div class="controls">
            <button id="heroPlay" class="btn accent"><i class="fa fa-play"></i> Play</button>
            <button id="heroAdd" class="btn"><i class="fa fa-plus"></i> Add</button>
            <span id="heroBadge" class="badge">Auto</span>
          </div>
        </div>
      </div>
    </div>

    <div style="margin-top:6px">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <div>
          <button id="refreshAll" class="btn">Refresh</button>
        </div>
      </div>

      <div class="tabs" role="tablist" aria-label="recommendation tabs" style="margin-top:12px">
        <button class="tab active" data-tab="eng">English Trending</button>
        <button class="tab" data-tab="hin">Hindi Trending</button>
        <button class="tab" data-tab="mood">Mood Mix</button>
      </div>

      <div id="tabPanels" style="margin-top:12px">
        <div id="engPanel" class="section" style="display:block">
          <div class="grid" id="engGrid"></div>
          <div class="grid" id="engMore"></div>
        </div>

        <div id="hinPanel" class="section" style="display:none">
          <div class="grid" id="hinGrid"></div>
          <div class="grid" id="hinMore"></div>
        </div>

        <div id="moodPanel" class="section" style="display:none">
          <div id="moodInfo" style="color:var(--muted);margin-bottom:8px">Chill • Lo-fi • Ambient previews from iTunes
          </div>
          <div class="grid" id="moodGrid"></div>
          <div class="grid" id="moodMore"></div>
        </div>
      </div>

      <div style="text-align:center;margin-top:12px">
        <button id="loadMore" class="btn">Load More</button>
      </div>
    </div>

    <div style="margin-top:18px">
      <h3>Search Results</h3>
      <div id="searchResults" class="grid"></div>
    </div>

    <div class="main-layout">
      <div>
        <div class="section">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <h3 style="margin:0">My Playlist</h3>
            <div><button id="savePlaylist" class="btn">Save</button></div>
          </div>
          <div id="playlistGrid" class="playlist-grid" style="margin-top:10px"></div>
          <div style="color:var(--muted);font-size:13px;margin-top:6px">Tip: click poster to open full player. Drag to
            reorder (desktop).</div>
        </div>

        <div class="section" style="margin-top:12px">
          <h3 style="margin:0">Recently Played</h3>
          <div id="recentGrid" style="margin-top:10px"></div>
        </div>
      </div>

      <div>
        <div class="section">
          <h4 style="margin:0">Settings</h4>
          <div style="margin-top:8px;display:flex;flex-direction:column;gap:8px">
            <div><label>Cache audio via Service Worker: <span id="swStatus" class="badge">inactive</span></label></div>
            <div style="display:flex;gap:8px">
              <button id="clearCache" class="btn">Clear Cache</button>
              <button id="clearDownloads" class="btn">Clear Playlist</button>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- MINI PLAYER WRAPPER (hidden until play) -->
  <div class="mini-wrap" id="miniWrap" aria-hidden="true">
    <div class="mini" id="mini">
      <div class="mini-left">
        <div class="t" id="miniTitle">No track</div>
        <div class="a" id="miniArtist"></div>
      </div>

      <div class="mini-center">
        <div class="mini-controls">
          <div class="mini-btn" id="miniPrev"><i class="fa fa-backward"></i></div>
          <div class="mini-btn big" id="miniPlay"><i class="fa fa-play"></i></div>
          <div class="mini-btn" id="miniNext"><i class="fa fa-forward"></i></div>
        </div>

        <!-- REPLACED old range with Spotify-style green progress bar -->
        <div class="mini-timeline" style="align-items:center;">
          <div class="mini-time" id="miniCur">0:00</div>
          <div style="flex:1;padding:0 8px;">
            <div id="miniProgressContainer"
              style="background:#2a2a2a;height:6px;border-radius:6px;position:relative;cursor:pointer;">
              <div id="miniProgressBar"
                style="width:0%;height:100%;background:var(--accent);border-radius:6px;transition:width .12s linear;">
              </div>
            </div>
          </div>
          <div class="mini-time" id="miniDur">0:00</div>
        </div>
      </div>

      <div class="mini-right">
        <i class="fa fa-volume-up" style="color:var(--muted)"></i>
        <input type="range" id="miniVolume" min="0" max="1" step="0.01" value="1">
        <div class="full-btn" id="miniFullscreen" title="Fullscreen"><i class="fa fa-expand"></i></div>
      </div>
    </div>
  </div>

  <!-- existing overlay player -->
  <div class="overlay" id="overlay">
    <div class="player-panel" role="dialog" aria-modal="true" aria-label="Full player">
      <div class="left-col">
        <img id="overlayArt" src="" alt="cover">
        <div style="width:100%;display:flex;flex-direction:column;gap:8px;align-items:center">
          <div style="font-weight:800;font-size:1.2rem" id="overlayTitle">Title</div>
          <div style="color:var(--muted)" id="overlayArtist">Artist</div>

          <div style="display:flex;gap:8px;align-items:center;margin-top:8px">
            <button id="ovPrev" class="btn small" aria-label="Previous track"><i class="fa fa-backward"></i></button>
            <button id="ovPlay" class="btn small accent" aria-label="Play/Pause"><i class="fa fa-play"></i></button>
            <button id="ovNext" class="btn small" aria-label="Next track"><i class="fa fa-forward"></i></button>
            <button id="ovShuffle" class="btn small" aria-label="Toggle shuffle"><i class="fa fa-random"></i></button>
            <button id="ovRepeat" class="btn small" aria-label="Toggle repeat"><i class="fa fa-repeat"></i></button>
            <button id="ovDownload" class="btn small" title="Download track"><i class="fa fa-download"></i></button>
            <button id="ovClose" class="btn small" title="Minimize player"><i class="fa fa-times"></i></button>
          </div>

          <div style="width:100%;display:flex;gap:10px;align-items:center;margin-top:6px">
            <div id="ovCur" style="width:56px;text-align:center;color:var(--muted)">0:00</div>
            <input id="ovSeek" type="range" min="0" max="100" value="0" style="flex:1">
            <div id="ovDur" style="width:56px;text-align:center;color:var(--muted)">0:00</div>
          </div>

          <div style="width:100%;display:flex;gap:8px;align-items:center;justify-content:center;margin-top:6px">
            <div style="display:flex;align-items:center;gap:8px">
              <i class="fa fa-volume-up" style="color:var(--muted)"></i>
              <input id="ovVolume" type="range" min="0" max="1" step="0.01" value="1" style="width:160px">
            </div>
          </div>

        </div>
      </div>

      <div class="right-col">
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:10px">
          <div style="font-weight:800">Up Next</div>
          <div style="color:var(--muted)" id="moreInfo">More from this list</div>
        </div>
        <div class="queue-list" id="queueList"></div>

        <div style="margin-top:12px">
          <div style="font-weight:700;margin-bottom:8px">Suggested Lists</div>
          <div id="suggestions" style="display:flex;gap:8px;flex-wrap:wrap"></div>
        </div>
      </div>
    </div>
  </div>

  <div style="position:fixed;left:20px;bottom:420px;z-index:9999">
    <div id="toast"
      style="display:none;background:var(--accent);color:#000;padding:8px 12px;border-radius:8px;font-weight:700"></div>
  </div>

  <footer class="footer">
    <div class="footer-content">

      <div class="footer-brand">
        <h2 class="footer-logo"><i class="fas fa-infinity"></i> ChillBox</h2>
        <p>Stream Movies, play<br>Games, and enjoy<br>Music – all in one place.</p>

        <div class="footer-social">
          <a href="#"><i class="fab fa-facebook"></i></a>
          <a href="#"><i class="fab fa-instagram"></i></a>
          <a href="#"><i class="fab fa-twitter"></i></a>
          <a href="#"><i class="fab fa-youtube"></i></a>
        </div>
      </div>

      <div class="footer-section">
        <h3>Sections</h3>
        <a href="index.html">Movies</a>
        <a href="Music.Html">Music</a>
        <a href="Games.html">Games</a>
        <a href="AboutUs.html">About Us</a>
      </div>

      <div class="footer-section">
        <h3>Support</h3>
        <a href="#">FAQ</a>
        <a href="#">Privacy Policy</a>
        <a href="#">Terms & Conditions</a>
      </div>

    </div>

    <p class="footer-copy">© 2025 ChillBox Entertainment. All rights reserved.</p>
  </footer>

  <script>
    // Performance optimization helpers
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }
    function throttle(func, limit) {
      let inThrottle;
      return function () {
        const args = arguments;
        const context = this;
        if (!inThrottle) {
          func.apply(context, args);
          inThrottle = true;
          setTimeout(() => inThrottle = false, limit);
        }
      }
    }

    // Simple shuffle
    function shuffleArray(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    const itunesFetch = async (term, limit = 12, country = 'US') => {
      try {
        const q = encodeURIComponent(term);
        const url = `https://itunes.apple.com/search?term=${q}&entity=song&limit=${limit}&country=${country}&media=music`;
        const r = await fetch(url);
        const data = await r.json();
        return (data && data.results) ? data.results : [];
      } catch (e) {
        console.warn('iTunes fetch error', e);
        return [];
      }
    };

    /* UI refs */
    const engGrid = document.getElementById('engGrid'), hinGrid = document.getElementById('hinGrid'), moodGrid = document.getElementById('moodGrid');
    const engMore = document.getElementById('engMore'), hinMore = document.getElementById('hinMore'), moodMore = document.getElementById('moodMore');
    const heroBg = document.getElementById('heroBg'), heroArt = document.getElementById('heroArt'), heroTitle = document.getElementById('heroTitle'), heroArtist = document.getElementById('heroArtist');
    const heroPlay = document.getElementById('heroPlay'), heroAdd = document.getElementById('heroAdd'), heroBadge = document.getElementById('heroBadge');

    const searchInput = document.getElementById('searchInput'), searchBtn = document.getElementById('searchBtn'), searchResults = document.getElementById('searchResults');

    const playlistGrid = document.getElementById('playlistGrid'), recentGrid = document.getElementById('recentGrid');
    const savePlaylistBtn = document.getElementById('savePlaylist'), clearDownloadsBtn = document.getElementById('clearDownloads');
    const clearCacheBtn = document.getElementById('clearCache');

    const overlay = document.getElementById('overlay');
    const overlayArt = document.getElementById('overlayArt'), overlayTitle = document.getElementById('overlayTitle'), overlayArtist = document.getElementById('overlayArtist');
    const ovPlay = document.getElementById('ovPlay'), ovPrev = document.getElementById('ovPrev'), ovNext = document.getElementById('ovNext'), ovClose = document.getElementById('ovClose');
    const ovShuffle = document.getElementById('ovShuffle'), ovRepeat = document.getElementById('ovRepeat'), ovDownload = document.getElementById('ovDownload');
    const ovSeek = document.getElementById('ovSeek'), ovCur = document.getElementById('ovCur'), ovDur = document.getElementById('ovDur'), ovVolume = document.getElementById('ovVolume');
    const queueList = document.getElementById('queueList'), suggestions = document.getElementById('suggestions'), moreInfo = document.getElementById('moreInfo');

    const miniWrap = document.getElementById('miniWrap'), mini = document.getElementById('mini');
    const miniTitle = document.getElementById('miniTitle'), miniArtist = document.getElementById('miniArtist');
    const miniPlay = document.getElementById('miniPlay'), miniPrev = document.getElementById('miniPrev'), miniNext = document.getElementById('miniNext');
    const miniVolume = document.getElementById('miniVolume');
    const miniFullscreen = document.getElementById('miniFullscreen');
    const miniProgressBar = document.getElementById('miniProgressBar');
    const miniProgressContainer = document.getElementById('miniProgressContainer');
    const toastEl = document.getElementById('toast');

    const loadMoreBtn = document.getElementById('loadMore'), refreshAllBtn = document.getElementById('refreshAll');

    const tabs = document.querySelectorAll('.tab');
    const tabPanels = {
      eng: document.getElementById('engPanel'),
      hin: document.getElementById('hinPanel'),
      mood: document.getElementById('moodPanel')
    };
    const grids = {
      eng: engGrid,
      hin: hinGrid,
      mood: moodGrid
    };
    const moreGrids = {
      eng: engMore,
      hin: hinMore,
      mood: moodMore
    }

    /* state */
    const MOODS = [{ key: 'chill', q: 'chill' }, { key: 'lofi', q: 'lo-fi' }, { key: 'ambient', q: 'ambient' }];
    let currentMood = MOODS[0];
    let settings = { shuffle: false, repeat: false, volume: 1 };
    let queue = [];           // current overlay queue (array of track objects)
    let currentIndex = -1;    // index in queue
    let activeTab = 'eng';
    let currentHeroTrack = {}; // To store the track currently displayed in the hero section

    /* audio + visualizer small setup */
    const audio = new Audio();
    audio.crossOrigin = "anonymous";
    audio.preload = 'auto';
    audio.volume = settings.volume;

    /* loading indicator helper */
    function showLoader(el) {
      el.innerHTML = `<div style="padding:18px;display:flex;align-items:center;gap:12px">\n    <div class=\"loader\"><i class=\"fa fa-music\"></i></div><div style=\"color:var(--muted)\">Loading...</div>\n  </div>`;
    }
    function hideLoader(el) { el.innerHTML = ''; }

    /* toast */
    function toast(msg, ms = 1400) {
      toastEl.textContent = msg; toastEl.style.display = 'block';
      clearTimeout(toastEl._t); toastEl._t = setTimeout(() => { toastEl.style.display = 'none'; }, ms);
    }

    /* safe text */
    function safe(s) { return s ? String(s).replace(/&/g, '&amp;').replace(/</g, '&lt;') : ''; }

    /* time formatter */
    function formatTime(seconds) {
      if (isNaN(seconds)) return '0:00';
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
      return `${minutes}:${secs}`;
    }

    /* render card */
    function createCard(item) {
      // Ensure previewUrl exists before creating card, or handle gracefully
      if (!item.previewUrl && !item.audio) return null;

      const art = item.artworkUrl100 ? item.artworkUrl100.replace('100x100', '600x600') : (item.artwork || 'https://picsum.photos/300');
      const title = safe(item.trackName || item.trackName || '');
      const artist = safe(item.artistName || item.artist || '');
      const preview = (item.previewUrl || item.audio) || '';
      const div = document.createElement('div');
      div.className = 'card';
      div.innerHTML = `\n    <img src="${art}" alt="" loading="lazy">\n    <h4>${title}</h4>\n    <div class="meta-muted">${artist}</div>\n    <div class="row">\n      <button class="btn add small" data-audio="${preview}" data-title="${title}" data-artist="${artist}" data-art="${art}"><i class="fa fa-plus"></i></button>\n      <button class="btn play small" data-audio="${preview}" data-title="${title}" data-artist="${artist}" data-art="${art}"><i class="fa fa-play"></i></button>\n    </div>\n  `;

      const trackObj = {
        trackName: title,
        artistName: artist,
        audio: preview,
        artwork: art
      };

      // poster click: open overlay and auto-play
      div.querySelector('img').style.cursor = 'pointer';
      div.querySelector('img').addEventListener('click', () => {
        openOverlayAndPlay(trackObj, item._source || activeTab);
      });
      // play button also opens overlay
      div.querySelector('.play').addEventListener('click', () => {
        openOverlayAndPlay(trackObj, item._source || activeTab);
      });
      // add to playlist
      div.querySelector('.add').addEventListener('click', (e) => {
        addToPlaylist(trackObj);
        e.stopPropagation();
      });
      return div;
    }

    /* add to playlist (simple in-memory then render) */
    let playlist = [];
    function addToPlaylist(item) {
      if (!item || !item.audio) return toast('No preview available');
      // Check if track already exists by audio URL (more reliable than title/artist)
      if (playlist.find(p => p.audio === item.audio)) return toast('Already in playlist');
      playlist.push({ ...item, id: Math.random().toString(36).slice(2, 9) });
      renderPlaylist();
      toast('Added to playlist');
    }

    /* drag and drop playlist */
    let dragSrcEl = null;

    function handleDragStart(e) {
      dragSrcEl = this;
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/html', this.innerHTML);
      setTimeout(() => { this.classList.add('dragging'); }, 0);
    }

    function handleDragOver(e) {
      if (e.preventDefault) e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      return false;
    }

    function handleDrop(e) {
      if (e.stopPropagation) e.stopPropagation();

      if (dragSrcEl !== this) {
        const fromIndex = Array.from(playlistGrid.children).indexOf(dragSrcEl);
        const toIndex = Array.from(playlistGrid.children).indexOf(this);

        // Reorder the playlist array
        const movedItem = playlist.splice(fromIndex, 1)[0];
        playlist.splice(toIndex, 0, movedItem);

        // Re-render to update the UI
        renderPlaylist();
        toast('Playlist reordered');
      }
      return false;
    }

    function handleDragEnd(e) {
      document.querySelectorAll('.playlist-card').forEach(card => card.classList.remove('dragging'));
    }

    function renderPlaylist() {
      playlistGrid.innerHTML = '';
      if (!playlist.length) { playlistGrid.innerHTML = '<div style="color:var(--muted)">Your playlist is empty</div>'; return; }
      playlist.forEach((p, idx) => {
        const el = document.createElement('div'); el.className = 'card playlist-card';
        el.style.display = 'flex'; el.style.alignItems = 'center'; el.style.gap = '8px';
        el.setAttribute('draggable', 'true'); // Make draggable
        el.innerHTML = `<img src="${safe(p.artwork)}" style="width:56px;height:56px;border-radius:6px;object-fit:cover" loading="lazy">\n      <div style="flex:1">\n        <div style="font-weight:700">${safe(p.trackName)}</div>\n        <div style="color:var(--muted)">${safe(p.artistName)}</div>\n      </div>\n       <div style="display:flex;flex-direction:column;gap:6px">\n        <button class="btn small play-item" data-idx="${idx}"><i class="fa fa-play"></i></button>\n        <button class="btn small" data-remove="${idx}" style="background:#ff6b6b;color:#000"><i class="fa fa-trash"></i></button>\n      </div>\n    `;

        // Drag and Drop Listeners
        el.addEventListener('dragstart', handleDragStart);
        el.addEventListener('dragover', handleDragOver);
        el.addEventListener('drop', handleDrop);
        el.addEventListener('dragend', handleDragEnd);

        el.querySelector('[data-remove]')?.addEventListener('click', (e) => {
          playlist.splice(idx, 1); renderPlaylist();
          e.stopPropagation(); // Prevent play action
        });
        el.querySelector('.play-item')?.addEventListener('click', (e) => {
          enqueueAndPlayFromPlaylist(idx);
          e.stopPropagation(); // Prevent play action
        });
        // Full player open on card click
        el.addEventListener('click', () => {
          enqueueAndPlayFromPlaylist(idx);
        });

        playlistGrid.appendChild(el);
      });
    }

    /* recent (simple memory) */
    let recent = [];
    async function pushRecent(t) {
      if (!t || !t.audio) return;
      const key = (t.trackName || '') + '|' + (t.artistName || '');
      // remove duplicate
      recent = recent.filter(r => r._key !== key);
      recent.unshift({ ...t, _key: key, time: Date.now() });
      if (recent.length > 12) recent.length = 12;
      renderRecent();
    }
    function renderRecent() {
      recentGrid.innerHTML = '';
      if (!recent.length) { recentGrid.innerHTML = '<div style="color:var(--muted)">No recent plays</div>'; return; }
      recent.forEach(r => {
        const el = document.createElement('div'); el.className = 'card'; el.style.padding = '8px'; el.style.textAlign = 'left';
        el.innerHTML = `<div style="font-weight:700">${safe(r.trackName)}</div><div style="color:var(--muted)">${safe(r.artistName)}</div>`;
        el.addEventListener('click', () => openOverlayAndPlay({ trackName: r.trackName, artistName: r.artistName, artwork: r.artwork, audio: r.audio }, 'recent'));
        recentGrid.appendChild(el);
      });
    }

    /* enqueue and play from playlist */
    function enqueueAndPlayFromPlaylist(idx) {
      if (idx < 0 || idx >= playlist.length) return;
      // set queue to playlist copy
      queue = playlist.map(p => ({ ...p }));
      currentIndex = idx;
      openOverlay();
      loadQueueToOverlay();
      playIndex(currentIndex);
    }

    /* overlay helpers */
    function openOverlay() {
      // FIX: Disable body scrolling when overlay is open
      overlay.style.display = 'flex';
      document.body.style.overflow = 'hidden';
    }

    // closeOverlay now MINIMIZES: hide overlay, keep audio playing, and show mini player
    function closeOverlay() {
      // FIX: Re-enable body scrolling when overlay is closed
      overlay.style.display = 'none';
      document.body.style.overflow = '';
      // If currently in fullscreen mode (e.g., if user minimized via ovClose), exit it.
      if (document.fullscreenElement === overlay) {
        document.exitFullscreen?.();
      }
      // keep audio playing — DO NOT pause
      // Show mini player
      showMini();
      toast('Minimized');
    }

    /* open overlay with a single track (and populate "more" from active tab) */
    async function openOverlayAndPlay(track, sourceTab = 'eng') {
      let list = [];
      try {
        // Determine the base list to populate the queue
        if (sourceTab === 'hin') list = await itunesFetch('bollywood', 24, 'IN');
        else if (sourceTab === 'mood') list = await itunesFetch(currentMood.q, 24);
        else if (sourceTab === 'recent' || sourceTab === 'playlist') list = []; // Don't re-fetch for these, handle below
        else list = await itunesFetch('top hits', 24);

        // Map and normalize the fetched list
        list = list.map(it => ({
          trackName: it.trackName,
          artistName: it.artistName,
          audio: it.previewUrl,
          artwork: it.artworkUrl100 ? it.artworkUrl100.replace('100x100', '600x600') : 'https://picsum.photos/300'
        }));

        if (sourceTab === 'playlist') {
          // If coming from playlist, use the global playlist array as the queue
          queue = playlist.map(p => ({ ...p }));
          currentIndex = queue.findIndex(x => x.audio === track.audio || x.trackName === track.trackName);
          if (currentIndex === -1) currentIndex = 0; // Fallback
        } else {
          // Handle non-playlist sources: ensure clicked track is at the start
          let idx = list.findIndex(x => x.audio === track.audio || x.trackName === track.trackName);
          if (idx === -1) {
            queue = [{ ...track }, ...list];
            currentIndex = 0;
          } else {
            queue = list.slice(idx).concat(list.slice(0, idx));
            currentIndex = 0;
          }
        }
      } catch (e) {
        console.error(e);
        // fallback: single track queue
        queue = [{ ...track }];
        currentIndex = 0;
      }
      // show overlay + queue
      openOverlay();
      loadQueueToOverlay();
      playIndex(currentIndex);
    }
    /* load queue into right column list and suggestions */
    function loadQueueToOverlay() {
      queueList.innerHTML = '';
      queue.forEach((q, i) => {
        const item = document.createElement('div');
        item.className = 'queue-item' + (i === currentIndex ? ' active' : '');
        item.dataset.idx = i;
        item.innerHTML = `\n      <img src="${safe(q.artwork)}" alt="" loading="lazy">\n      <div class="queue-meta">\n        <div class="t">${safe(q.trackName)}</div>\n        <div class="a">${safe(q.artistName)}</div>\n      </div>\n      <div><button class="btn small play-quick" data-idx="${i}"><i class="fa fa-play"></i></button></div>\n    `;
        item.addEventListener('click', () => {
          playIndex(Number(item.dataset.idx));
        });
        item.querySelector('.play-quick')?.addEventListener('click', (ev) => {
          ev.stopPropagation();
          playIndex(Number(ev.currentTarget.dataset.idx));
        });
        queueList.appendChild(item);
      });

      // suggestions: show small chips for other mood/genres
      suggestions.innerHTML = '';
      const chips = [
        { t: 'Chill', q: 'chill' },
        { t: 'Lofi', q: 'lo-fi' },
        { t: 'Ambient', q: 'ambient' },
        { t: 'Indie', q: 'indie' },
        { t: 'Acoustic', q: 'acoustic' },
        { t: 'Instrumental', q: 'instrumental' }
      ];
      chips.forEach(c => {
        const btn = document.createElement('button');
        btn.className = 'btn small'; btn.textContent = c.t; btn.style.background = 'rgba(255,255,255,0.03)';
        btn.addEventListener('click', async () => {
          // fetch and append tracks for this suggestion
          const arr = await itunesFetch(c.q, 14);
          const mapped = arr.map(it => ({ trackName: it.trackName, artistName: it.artistName, audio: it.previewUrl, artwork: (it.artworkUrl100 || '').replace('100x100', '600x600') }));
          // append and refresh queue view
          queue = queue.concat(mapped);
          loadQueueToOverlay();
          toast(`Added ${c.t} songs to queue`);
        });
        suggestions.appendChild(btn);
      });
    }

    /* play index in queue */
    function playIndex(idx) {
      if (idx < 0 || idx >= queue.length) return;
      const prevIndex = currentIndex;
      currentIndex = idx;
      const t = queue[idx];

      if (!t || !t.audio) {
        toast('No audio URL for this track');
        if (idx < queue.length - 1) playIndex(idx + 1);
        return;
      }

      audio.src = t.audio;
      audio.play().catch(e => console.warn('play blocked', e));
      overlayArt.src = t.artwork || '';
      overlayTitle.textContent = t.trackName || '';
      overlayArtist.textContent = t.artistName || '';
      ovPlay.innerHTML = '<i class="fa fa-pause"></i>';
      miniPlay.innerHTML = '<i class="fa fa-pause"></i>';
      // show mini player
      showMini();
      // miniArt is not defined, skipping miniArt update (it's not in HTML anyway)
      // miniArt && (miniArt.src = t.artwork || ''); 
      miniTitle.textContent = t.trackName || '';
      miniArtist.textContent = t.artistName || '';
      // highlight active in queue list
      const currentActive = document.querySelector(`.queue-item[data-idx="${prevIndex}"]`);
      if (currentActive) currentActive.classList.remove('active');
      const newActive = document.querySelector(`.queue-item[data-idx="${currentIndex}"]`);
      if (newActive) newActive.classList.add('active');
      // Scroll to active item in overlay
      if (newActive) newActive.scrollIntoView({ behavior: 'smooth', block: 'nearest' });

      pushRecent(t);
    }

    /* hero content cycling */
    let heroInterval;
    let heroTracks = [];
    let heroTrackIndex = 0;
    const HERO_INTERVAL_MS = 10000;

    async function loadHeroTracks() {
      heroTracks = await itunesFetch('chill lo-fi ambient', 12);
      if (heroTracks.length) {
        cycleHeroContent();
        if (heroInterval) clearInterval(heroInterval);
        heroInterval = setInterval(cycleHeroContent, HERO_INTERVAL_MS);
      }
    }

    function cycleHeroContent() {
      if (!heroTracks.length) return;
      const item = heroTracks[heroTrackIndex];
      const art = item.artworkUrl100 ? item.artworkUrl100.replace('100x100', '600x600') : 'https://picsum.photos/300';

      heroArt.src = art;
      heroArt.loading = 'eager'; // Hero image should load immediately
      heroBg.style.backgroundImage = `url('${art}')`;

      currentHeroTrack = {
        trackName: item.trackName,
        artistName: item.artistName,
        audio: item.previewUrl,
        artwork: art
      };

      heroTrackIndex = (heroTrackIndex + 1) % heroTracks.length;
    }

    /* data fetching and rendering for tabs - improved dedupe & randomness */
    let currentResults = {}; // stores results for each tab to enable Load More

    // Keep seen sets to prevent duplicates across tabs and loads
    const seenGlobal = new Set(); // previewUrl or fallback key across all tabs
    const seenPerTab = { eng: new Set(), hin: new Set(), mood: new Set() };

    // Helper to derive stable key for a track item
    function trackKeyForItem(it) {
      if (!it) return null;
      const audio = it.previewUrl || it.audio || '';
      if (audio) return audio;
      // fallback
      return (it.trackName || '') + '|' + (it.artistName || '');
    }

    async function fetchAndRenderTab(tabKey, isMore = false) {
      const targetGrid = isMore ? moreGrids[tabKey] : grids[tabKey];
      showLoader(targetGrid);

      let results = [];
      let term = '';
      let country = 'US';

      if (tabKey === 'eng') term = 'top hits usa';
      else if (tabKey === 'hin') { term = 'trending hindi'; country = 'IN'; }
      else if (tabKey === 'mood') term = currentMood.q;

      // When requesting "more", fetch a larger pool to allow picking unique items
      const requestLimit = isMore ? 50 : 18;

      results = await itunesFetch(term, requestLimit, country);

      // keep a normalized map with source information
      results = results.map(r => ({ ...r, _source: tabKey }));

      // Randomize order so Load More behaves "randomly"
      shuffleArray(results);

      // Filter out items that we've already shown anywhere
      const filtered = [];
      for (let r of results) {
        const k = trackKeyForItem(r);
        if (!k) continue;
        if (seenGlobal.has(k)) continue; // already shown in any tab or earlier loads
        // otherwise keep
        filtered.push(r);
      }

      // Decide how many to append
      const want = isMore ? 12 : 18;
      const toAppend = filtered.slice(0, want);

      // If initial load (not isMore), we append to grids and also store all results into currentResults for that tab
      currentResults[tabKey] = (currentResults[tabKey] || []).concat(toAppend);

      hideLoader(targetGrid);

      // Only create cards for items that are still unique
      const fragment = document.createDocumentFragment();
      toAppend.forEach(r => {
        const card = createCard(r);
        if (card) fragment.appendChild(card);
        // mark as seen everywhere so future loads don't duplicate
        const k = trackKeyForItem(r);
        if (k) { seenGlobal.add(k); seenPerTab[tabKey].add(k); }
      });
      targetGrid.appendChild(fragment);

      // If we received less than the requested want and there are no unique results, hide Load More
      if (toAppend.length < (isMore ? 12 : 18)) {
        // Try one more graceful attempt only for "Load More": fetch again with a slightly different search term to increase variety
        if (isMore && toAppend.length === 0) {
          // small set of fallback terms to increase randomness
          const fallbackTerms = (tabKey === 'hin') ? ['bollywood', 'bollywood top'] : (tabKey === 'mood') ? ['chill', 'lofi', 'ambient'] : ['pop', 'indie', 'hits'];
          // attempt fetching once using another term to get some unique items
          for (let t of shuffleArray(fallbackTerms).slice(0, 2)) {
            const extra = await itunesFetch(t, 50, country);
            const mapped = extra.map(r => ({ ...r, _source: tabKey }));
            shuffleArray(mapped);
            const add = [];
            for (let r of mapped) {
              const k = trackKeyForItem(r);
              if (!k) continue;
              if (seenGlobal.has(k)) continue;
              add.push(r);
              if (add.length >= 12) break;
            }
            if (add.length) {
              const frag2 = document.createDocumentFragment();
              add.forEach(r => {
                const card = createCard(r);
                if (card) frag2.appendChild(card);
                const k = trackKeyForItem(r);
                if (k) { seenGlobal.add(k); seenPerTab[tabKey].add(k); }
              });
              targetGrid.appendChild(frag2);
              currentResults[tabKey] = (currentResults[tabKey] || []).concat(add);
              break;
            }
          }
        }
        // If still not many results, hide the Load More button
        loadMoreBtn.style.display = 'none';
      } else {
        // show Load More (user may continue)
        if (!isMore) loadMoreBtn.style.display = 'block';
        else loadMoreBtn.style.display = 'block';
      }
    }

    /* Service Worker Status */
    function updateSWStatus() {
      const swStatus = document.getElementById('swStatus');
      if ('serviceWorker' in navigator) {
        swStatus.textContent = 'available';
        swStatus.style.background = 'var(--accent)';
      } else {
        swStatus.textContent = 'unsupported';
        swStatus.style.background = '#ff6b6b';
      }
    }

    /* Cache Clearing Logic */
    function clearCache() {
      if ('caches' in window) {
        caches.keys().then(names => {
          names.forEach(name => {
            caches.delete(name);
          });
          toast('Cache cleared successfully');
        }).catch(err => {
          console.error('Error clearing cache:', err);
          toast('Error clearing cache');
        });
      } else {
        toast('Cache API not supported in this browser');
      }
    }

    /* Mini Player Visibility helpers */
    function hideMini() {
      miniWrap.style.display = 'none';
      miniWrap.setAttribute('aria-hidden', 'true');
    }

    function showMini() {
      miniWrap.style.display = 'flex';
      miniWrap.setAttribute('aria-hidden', 'false');
    }

    /* event listeners (initial setup) */
    document.addEventListener('DOMContentLoaded', async () => {
      loadHeroTracks();
      // initial load for default tab
      await fetchAndRenderTab('eng');
      renderPlaylist();
      renderRecent();
      updateSWStatus();

      // Sync initial volume state to controls
      ovVolume.value = audio.volume;
      miniVolume.value = audio.volume;

      // Load playlist from localStorage
      try {
        const saved = localStorage.getItem('chillbox-playlist');
        if (saved) {
          playlist = JSON.parse(saved);
          renderPlaylist();
        }
      } catch (e) {
        console.error('Error loading playlist from storage:', e);
      }
    });

    // --- Tab Switching ---
    tabs.forEach(tab => {
      tab.addEventListener('click', async (e) => {
        const key = e.currentTarget.dataset.tab;
        if (key === activeTab) return;

        // Update active state
        document.querySelector('.tab.active')?.classList.remove('active');
        e.currentTarget.classList.add('active');
        activeTab = key;

        // Hide all panels
        Object.values(tabPanels).forEach(p => p.style.display = 'none');
        // Show active panel
        tabPanels[activeTab].style.display = 'block';

        // Load content if empty (and ensure not to duplicate already seen items)
        if (grids[activeTab].children.length === 0) {
          await fetchAndRenderTab(activeTab);
        } else {
          // If already loaded, check if Load More should be visible
          const hasMoreContent = (currentResults[activeTab]?.length || 0) >= 18;
          loadMoreBtn.style.display = hasMoreContent && moreGrids[activeTab]?.children.length === 0 ? 'block' : 'none';
        }
      });
    });

    // --- Load More / Refresh ---
    loadMoreBtn.addEventListener('click', async () => {
      // When clicked, fetch a larger pool and pick unique new items, to reduce duplication chance
      loadMoreBtn.style.display = 'none';
      await fetchAndRenderTab(activeTab, true);
      // show again if there are likely more (logic in fetchAndRenderTab will handle visibility)
    });

    refreshAllBtn.addEventListener('click', () => {
      // Reset grids and seen sets for current tab only to re-fetch fresh content
      grids[activeTab].innerHTML = '';
      moreGrids[activeTab].innerHTML = '';
      currentResults[activeTab] = [];
      // remove seen keys for this tab from global set so refresh can re-add new items
      seenPerTab[activeTab].forEach(k => seenGlobal.delete(k));
      seenPerTab[activeTab].clear();
      fetchAndRenderTab(activeTab);
      toast(`Refreshed ${activeTab} content`);
    });

    // --- Hero Controls ---
    heroPlay.addEventListener('click', () => {
      if (currentHeroTrack && currentHeroTrack.audio) {
        openOverlayAndPlay(currentHeroTrack, activeTab);
      } else {
        toast('No track to play. Try refreshing.');
      }
    });

    heroAdd.addEventListener('click', () => {
      if (currentHeroTrack && currentHeroTrack.audio) {
        addToPlaylist(currentHeroTrack);
      } else {
        toast('No track to add.');
      }
    });

    // --- Player Controls ---
    ovClose.addEventListener('click', closeOverlay);

    // Shuffle Toggle (with toast)
    ovShuffle.addEventListener('click', () => {
      settings.shuffle = !settings.shuffle;
      ovShuffle.classList.toggle('active', settings.shuffle);

      if (settings.shuffle) {
        settings.repeat = false;
        ovRepeat.classList.remove('active');
      }
      toast(settings.shuffle ? 'Shuffle Enabled' : 'Shuffle Disabled');
    });

    // Repeat Toggle (with toast)
    ovRepeat.addEventListener('click', () => {
      settings.repeat = !settings.repeat;
      ovRepeat.classList.toggle('active', settings.repeat);

      if (settings.repeat) {
        settings.shuffle = false;
        ovShuffle.classList.remove('active');
      }
      toast(settings.repeat ? 'Repeat Enabled' : 'Repeat Disabled');
    });

    // Seek Controls
    function handleSeek(e) {
      const pct = e.currentTarget.value;
      const time = audio.duration * (pct / 100);
      audio.currentTime = time;
    }
    ovSeek.addEventListener('input', handleSeek);
    // NOTE: mini progress is a clickable container instead of a range input — handled below

    // Volume Controls
    function handleVolumeChange(e) {
      const vol = parseFloat(e.currentTarget.value);
      audio.volume = vol;
      settings.volume = vol;
      ovVolume.value = vol;
      miniVolume.value = vol;
      // update icon in overlay/mini if present
      // (mini mute icon handled separately)
    }
    ovVolume.addEventListener('input', handleVolumeChange);
    miniVolume.addEventListener('input', handleVolumeChange);

    // Mini Player Mute Toggle (already had miniMute in original; keep previous behavior if present)
    let lastVolume = settings.volume;

    // Clear Playlist
    clearDownloadsBtn.addEventListener('click', () => {
      playlist = [];
      renderPlaylist();
      toast('Playlist Cleared');
    });

    // Clear Cache Button
    clearCacheBtn.addEventListener('click', () => {
      clearCache();
      toast('Clearing cache...');
    });

    /* audio events */
    let lastTimeUpdate = 0;
    audio.addEventListener('timeupdate', () => {
      const now = Date.now();
      if (now - lastTimeUpdate < 100) return;
      lastTimeUpdate = now;

      if (!audio.duration) return;
      const pct = (audio.currentTime / audio.duration) * 100;
      if (document.activeElement !== ovSeek) ovSeek.value = pct;
      // update mini progress bar (green) visually
      miniProgressBar.style.width = pct + '%';
      ovCur.textContent = formatTime(audio.currentTime); ovDur.textContent = formatTime(audio.duration);
      miniCur.textContent = formatTime(audio.currentTime); miniDur.textContent = formatTime(audio.duration);
    });

    // clicking/tapping the mini progress container seeks
    miniProgressContainer.addEventListener('click', (e) => {
      if (!audio.duration) return;
      const rect = miniProgressContainer.getBoundingClientRect();
      const x = (e.clientX - rect.left);
      const pct = Math.max(0, Math.min(1, x / rect.width)) * 100;
      audio.currentTime = audio.duration * (pct / 100);
      // immediately reflect UI
      miniProgressBar.style.width = pct + '%';
    });

    // --- ended handler using settings.shuffle + settings.repeat correctly ---
    audio.addEventListener('ended', () => {
      // Repeat current track (single-track repeat)
      if (settings.repeat) {
        audio.currentTime = 0;
        audio.play();
        return;
      }

      // Shuffle: pick a different random index if possible
      if (settings.shuffle && queue.length > 0) {
        let nextIdx = Math.floor(Math.random() * queue.length);
        // ensure not same index when possible
        if (nextIdx === currentIndex && queue.length > 1) {
          nextIdx = (nextIdx + 1) % queue.length;
        }
        playIndex(nextIdx);
        return;
      }

      // Normal progression
      if (currentIndex < queue.length - 1) playIndex(currentIndex + 1);
      else {
        audio.pause();
        audio.currentTime = 0;
        ovPlay.innerHTML = '<i class="fa fa-play"></i>';
        miniPlay.innerHTML = '<i class="fa fa-play"></i>';
      }
    });

    /* controls wiring */
    ovPlay.addEventListener('click', () => {
      if (audio.paused) {
        if (currentIndex === -1 && queue.length > 0) playIndex(0);
        else audio.play().catch(() => { });
        ovPlay.innerHTML = '<i class="fa fa-pause"></i>'; miniPlay.innerHTML = '<i class="fa fa-pause"></i>';
      }
      else {
        audio.pause();
        ovPlay.innerHTML = '<i class="fa fa-play"></i>'; miniPlay.innerHTML = '<i class="fa fa-play"></i>';
      }
    });

    miniPlay.addEventListener('click', (e) => {
      e.stopPropagation();
      if (audio.paused) {
        if (currentIndex === -1 && queue.length > 0) playIndex(0);
        else audio.play().catch(() => { });
        miniPlay.innerHTML = '<i class="fa fa-pause"></i>'; ovPlay.innerHTML = '<i class="fa fa-pause"></i>';
      }
      else {
        audio.pause();
        miniPlay.innerHTML = '<i class="fa fa-play"></i>'; ovPlay.innerHTML = '<i class="fa fa-play"></i>';
      }
    });

    // Prev/Next
    ovPrev.addEventListener('click', () => {
      if (queue.length === 0) return;
      if (settings.shuffle) {
        let idx = Math.floor(Math.random() * queue.length);
        if (idx === currentIndex && queue.length > 1) idx = (idx + 1) % queue.length;
        playIndex(idx);
      } else {
        playIndex(currentIndex <= 0 ? queue.length - 1 : currentIndex - 1);
      }
    });

    ovNext.addEventListener('click', () => {
      if (queue.length === 0) return;
      if (settings.shuffle) {
        let idx = Math.floor(Math.random() * queue.length);
        if (idx === currentIndex && queue.length > 1) idx = (idx + 1) % queue.length;
        playIndex(idx);
      } else {
        playIndex(currentIndex >= queue.length - 1 ? 0 : currentIndex + 1);
      }
    });

    miniPrev.addEventListener('click', (e) => { e.stopPropagation(); ovPrev.click(); });
    miniNext.addEventListener('click', (e) => { e.stopPropagation(); ovNext.click(); });

    // Download
    ovDownload.addEventListener('click', () => {
      if (queue[currentIndex]?.audio) {
        toast('Attempting to download... (May be blocked by browser/CORS)');
        window.open(queue[currentIndex].audio, '_blank');
      } else {
        toast('No track selected for download.');
      }
    });

    // Save Playlist
    savePlaylistBtn.addEventListener('click', () => {
      localStorage.setItem('chillbox-playlist', JSON.stringify(playlist));
      toast('Playlist saved locally!');
    });

    // Search functionality
    searchBtn.addEventListener('click', async () => {
      const query = searchInput.value.trim();
      if (!query) return toast('Please enter a search term');

      showLoader(searchResults);
      const results = await itunesFetch(query, 20);
      hideLoader(searchResults);

      searchResults.innerHTML = '';
      const fragment = document.createDocumentFragment();
      results.forEach(r => {
        // avoid showing duplicates in search results relative to what is already shown on page
        const k = trackKeyForItem(r);
        if (k && seenGlobal.has(k)) return;
        const card = createCard(r);
        if (card) fragment.appendChild(card);
      });
      searchResults.appendChild(fragment);

      if (results.length === 0) {
        searchResults.innerHTML = '<div style="color:var(--muted);text-align:center;padding:20px">No results found</div>';
      }
    });

    // Search on Enter key
    searchInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') searchBtn.click();
    });

    // Mini: open overlay when clicked (except clicks on controls)
    mini.addEventListener('click', (e) => {
      // if click target is a control, ignore
      if (e.target.closest('.mini-btn') || e.target.closest('.full-btn') || e.target.closest('input')) return;
      openOverlay(); // restore overlay
    });

    // Mini fullscreen button: toggle browser fullscreen for overlay
    miniFullscreen.addEventListener('click', (e) => {
      e.stopPropagation();
      if (!document.fullscreenElement) {
        // FIX: Ensure overlay is shown and scrolling is disabled BEFORE requesting fullscreen
        overlay.style.display = 'flex';
        document.body.style.overflow = 'hidden';
        overlay.requestFullscreen?.();
      } else {
        document.exitFullscreen?.();
      }
    });

    // Small safeguard: If overlay is closed via ESC or external, keep mini visible
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (overlay.style.display === 'flex' && !document.fullscreenElement) closeOverlay();
      }
    });

    // FIX: Handle fullscreen exit via ESC key or external means (to re-enable scrolling)
    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement) {
        // Fullscreen has exited. We need to check if the overlay is still visible (minimized state)
        // If the overlay is NOT visible, we re-enable body scrolling.
        if (overlay.style.display !== 'flex') {
          document.body.style.overflow = '';
        }
        // If the overlay IS visible, it means the user only pressed ESC (which exits fullscreen 
        // but doesn't necessarily hide the overlay if it was shown before). 
        // Since `closeOverlay` handles both hiding and exiting fullscreen, we trust that 
        // minimizing via the ovClose button handles scrolling correctly. 
        // For ESC exit in fullscreen, the flow is: ESC -> fullscreenchange fires. 
        // We ensure body scrolling is re-enabled if the overlay is no longer modal (hidden).
      }
    });


    // Performance: Add passive event listeners for scroll if needed
    document.addEventListener('scroll', throttle(() => {
      // Any scroll-related logic can go here
    }, 100), { passive: true });

    // Expose a simple play-from-card connector: when user clicks poster (handled in createCard),
    // openOverlayAndPlay -> playIndex will

    // --- Search recommendations, keyboard navigation, highlight, recent/trending ---
    (function () {
      const searchInput = document.getElementById('searchInput');
      const searchBtn = document.getElementById('searchBtn');
      const recBox = document.getElementById('searchRecommendations');
      const searchResults = document.getElementById('searchResults');

      // keep recent searches in localStorage
      const REC_KEY = 'chillbox-recent-searches';
      function getRecent() {
        try {
          return JSON.parse(localStorage.getItem(REC_KEY) || '[]');
        } catch { return []; }
      }
      function pushRecent(q) {
        if (!q) return;
        let arr = getRecent();
        arr = arr.filter(x => x !== q);
        arr.unshift(q);
        if (arr.length > 8) arr.length = 8;
        localStorage.setItem(REC_KEY, JSON.stringify(arr));
      }

      const trending = ['lofi', 'chill', 'top hits', 'bollywood', 'acoustic', 'instrumental', 'indie'];

      let items = []; // current displayed recommendation items
      let activeIndex = -1;

      // helper to highlight match in text
      function highlight(text, q) {
        if (!q) return text;
        const idx = text.toLowerCase().indexOf(q.toLowerCase());
        if (idx === -1) return text;
        return text.slice(0, idx) + '<strong>' + text.slice(idx, idx + q.length) + '</strong>' + text.slice(idx + q.length);
      }

      function renderRecommendations(arr, query) {
        items = arr;
        activeIndex = -1;
        recBox.innerHTML = '';
        if (!arr || arr.length === 0) {
          recBox.innerHTML = '<div class="rec-empty">No suggestions</div>';
          recBox.style.display = 'block';
          return;
        }
        arr.forEach((it, i) => {
          const div = document.createElement('div');
          div.className = 'search-rec-item';
          div.dataset.index = i;
          div.setAttribute('role', 'option');

          const thumb = document.createElement('img');
          thumb.className = 'search-rec-thumb';
          thumb.src = it.artwork || it.cover || 'https://picsum.photos/80';
          thumb.alt = '';

          const meta = document.createElement('div');
          meta.style.flex = '1';
          meta.innerHTML = `<div>${highlight(it.title || it.trackName || it.trackName || '', query)}</div><small>${highlight(it.artist || it.artistName || '', query)}</small>`;

          div.appendChild(thumb);
          div.appendChild(meta);

          div.addEventListener('click', () => {
            selectRecommendation(i);
          });

          div.addEventListener('mouseover', () => {
            setActive(i);
          });

          recBox.appendChild(div);
        });
        recBox.style.display = 'block';
      }

      function setActive(idx) {
        const nodes = recBox.querySelectorAll('.search-rec-item');
        nodes.forEach(n => n.classList.remove('active'));
        if (idx >= 0 && nodes[idx]) {
          nodes[idx].classList.add('active');
          activeIndex = idx;
          // ensure into view
          nodes[idx].scrollIntoView({ block: 'nearest' });
        } else activeIndex = -1;
      }

      async function fetchSuggestionsOnline(q) {
        // use the same itunesFetch function if available, else do a simple fetch
        if (typeof itunesFetch === 'function') {
          try {
            const res = await itunesFetch(q, 8);
            return res.map(r => ({ title: r.trackName, artist: r.artistName, artwork: (r.artworkUrl100 || '').replace('100x100', '200x200'), audio: r.previewUrl }));
          } catch (e) { return []; }
        } else {
          return [];
        }
      }

      async function updateRecommendations() {
        const q = searchInput.value.trim();
        if (!q) {
          // show recent + trending
          const recent = getRecent();
          const recs = [];
          recent.forEach(r => recs.push({ title: r, artist: 'Recent' }));
          trending.forEach(t => recs.push({ title: t, artist: 'Trending' }));
          renderRecommendations(recs, q);
          return;
        }
        // Search locally first: playlist, recent, currentResults if available
        const localMatches = [];
        try {
          // playlist array exists in page scope
          if (Array.isArray(window.playlist)) {
            window.playlist.forEach(p => {
              if ((p.trackName || '').toLowerCase().includes(q.toLowerCase()) || (p.artistName || '').toLowerCase().includes(q.toLowerCase())) {
                localMatches.push({ title: p.trackName, artist: p.artistName, artwork: p.artwork, audio: p.audio });
              }
            });
          }
          // recent
          getRecent().forEach(r => {
            if ((r || '').toLowerCase().includes(q.toLowerCase())) localMatches.push({ title: r, artist: 'Recent' });
          });
          // also include currentResults if present
          if (window.currentResults) {
            Object.values(window.currentResults).forEach(list => {
              (list || []).forEach(it => {
                const title = it.trackName || it.trackName || it.trackName || '';
                const artist = it.artistName || it.artistName || '';
                if (title.toLowerCase().includes(q.toLowerCase()) || artist.toLowerCase().includes(q.toLowerCase())) {
                  localMatches.push({ title, artist, artwork: it.artworkUrl100 ? it.artworkUrl100.replace('100x100', '200x200') : (it.artwork || ''), audio: it.previewUrl || it.audio });
                }
              });
            });
          }
        } catch (e) {
          // ignore
        }

        // Dedupe by title+artist
        const seen = new Set();
        const dedup = [];
        localMatches.forEach(i => {
          const k = (i.title || '') + '|' + (i.artist || '');
          if (!seen.has(k)) { seen.add(k); dedup.push(i); }
        });

        if (dedup.length >= 6) {
          renderRecommendations(dedup.slice(0, 6), q);
          return;
        }

        // supplement with online suggestions
        const online = await fetchSuggestionsOnline(q);
        const combined = dedup.concat(online).slice(0, 8);
        renderRecommendations(combined, q);
      }

      function selectRecommendation(idx) {
        const item = items[idx];
        if (!item) return;
        // push to recent searches (title)
        const query = item.title || item.trackName || item;
        if (typeof query === 'string') pushRecent(query);
        // set input and perform search — use existing search handler
        searchInput.value = item.title || item.trackName || query;
        recBox.style.display = 'none';
        // if recommendation has audio and a play helper exists, open overlay and play
        if (item.audio && typeof openOverlayAndPlay === 'function') {
          openOverlayAndPlay({ trackName: item.title, artistName: item.artist, audio: item.audio, artwork: item.artwork }, 'search');
        } else {
          // trigger the normal search button flow
          searchBtn.click();
        }
      }

      // keyboard navigation
      searchInput.addEventListener('keydown', (e) => {
        if (recBox.style.display !== 'block') return;
        if (e.key === 'ArrowDown') {
          e.preventDefault();
          setActive(Math.min(activeIndex + 1, items.length - 1));
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          setActive(Math.max(activeIndex - 1, 0));
        } else if (e.key === 'Enter') {
          if (activeIndex >= 0) {
            e.preventDefault();
            selectRecommendation(activeIndex);
          } else {
            // no active, perform normal search
            searchBtn.click();
          }
        } else if (e.key === 'Escape') {
          recBox.style.display = 'none';
        }
      });

      // input debounce to avoid excessive fetches
      let tId = 0;
      searchInput.addEventListener('input', () => {
        clearTimeout(tId);
        tId = setTimeout(updateRecommendations, 220);
      });

      // click outside to close recommendations
      document.addEventListener('click', (e) => {
        if (!e.target.closest('#searchRecommendations') && !e.target.closest('#searchInput')) {
          recBox.style.display = 'none';
        }
      });

      // on search button click, save to recent
      searchBtn.addEventListener('click', () => {
        const q = searchInput.value.trim();
        if (q) pushRecent(q);
      });

      // initial: show trending when focus
      searchInput.addEventListener('focus', () => {
        if (!searchInput.value.trim()) updateRecommendations();
      });

    })();

  </script>
<script type="module">
import { auth } from "./firebase.js";
import { onAuthStateChanged, signOut } from
"https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

onAuthStateChanged(auth,(user)=>{
  if(!user){
    location.href="login.html";
  }else{
    document.getElementById("userProfile").innerHTML =
      `👤 ${user.email} 
       <button onclick="logout()">Logout</button>`;
  }
});

window.logout = function(){
  signOut(auth).then(()=>location.href="login.html");
}
</script>
 <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-app.js";
      import { getFirestore, collection, getDocs, addDoc } from "https://www.gstatic.com/firebasejs/10.6.1/firebase-firestore.js";

      const firebaseConfig = {
        apiKey: "AIzaSyCG7awgsnkNtyOoqN7aRsRyAP4hNxZsvdo",
        authDomain: "chillbox-747f8.firebaseapp.com",
        projectId: "chillbox-747f8",
        storageBucket: "chillbox-747f8.firebasestorage.app",
        messagingSenderId: "808846502692",
        appId: "1:808846502692:web:fd3a70a823506207f261b1"
      };

      const app = initializeApp(firebaseConfig);
      const db = getFirestore(app);

      async function showMusic() {
        const musicCol = collection(db, "music");
        const musicSnapshot = await getDocs(musicCol);
        const musicList = musicSnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

        const container = document.getElementById("music");
        container.innerHTML = "";
        musicList.forEach(song => {
          const div = document.createElement("div");
          div.innerHTML = `<h3>${song.title} - ${song.artist}</h3><button onclick="playMusic('${song.id}')">Play</button>`;
          container.appendChild(div);
        });
      }

      async function playMusic(musicId) {
        try {
          await addDoc(collection(db, "user_activity"), {
            userId: "user123", // Replace with dynamic user ID
            contentType: "music",
            contentId: musicId,
            datePlayed: new Date().toISOString()
          });
          alert("Music played and activity recorded!");
        } catch (e) {
          console.error("Error recording activity: ", e);
        }
      }

      showMusic();
</script>
<script type="module">
import { auth, db } from "./firebase.js";
import { addDoc, collection } from
"https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

window.logActivity = async function(category, title) {
  const user = auth.currentUser;
  if (!user) return;

  await addDoc(
    collection(db, "users", user.uid, "activity"),
    {
      category,
      title,
      time: new Date()
    }
  );
};
</script>
<script type="module">
import { auth } from "./firebase.js";
import { onAuthStateChanged } from
"https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

onAuthStateChanged(auth, (user) => {
  if (!user) {
    location.replace("login.html");
  }
});
</script>
function logout() {
  auth.signOut().then(() => {
    location.replace("login.html");
  });
}
<script type="module">
import { auth } from "./firebase.js";
import { onAuthStateChanged, signOut } from
"https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";

const profileImg = document.getElementById("profileImg");
const profileMenu = document.getElementById("profileMenu");

onAuthStateChanged(auth, user => {
  if(!user){
    window.location.href = "login.html";
  }
});

profileImg.addEventListener("click", () => {
  profileMenu.style.display =
    profileMenu.style.display === "block" ? "none" : "block";
});

window.logout = function(){
  signOut(auth).then(() => location.href="login.html");
};

// close menu if clicked outside
document.addEventListener("click", e => {
  if(!e.target.closest(".profile-container")){
    profileMenu.style.display = "none";
  }
});

</script>
</body>

</html>
